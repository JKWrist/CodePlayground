#include <stdio.h>

/****************************************************************
 *  函数名称：默认对齐
 *  创建日期：2022-01-30 15:48:05
 *  作者：xujunze
 *  输入参数：无
 *  输出参数：无
 *  返回值：无
******************************************************************/
int a1 = 1;
int b1 = 2;
char c1 = 3;
char d1 = 4;

void test01()
{
	printf("a1 : %p\n", &a1);
	printf("b1 : %p\n", &b1);
	printf("c1 : %p\n", &c1);
	printf("d1 : %p\n", &d1);
	printf("---------------------------\n");
}

/****************************************************************
 *  函数名称：aligned(4)
 *  创建日期：2022-01-30 15:48:20
 *  作者：xujunze
 *  输入参数：无
 *  输出参数：无
 *  返回值：无
******************************************************************/
int a2 = 1;
int b2 = 2;
char c2 = 3;
char d2 __attribute__ ((aligned(4))) = 4;

void test02()
{
	printf("a2 : %p\n", &a2);
	printf("b2 : %p\n", &b2);
	printf("c2 : %p\n", &c2);
	printf("d2 : %p\n", &d2);
	printf("---------------------------\n");
}

/****************************************************************
 *  函数名称：结构体内存对齐
 *  创建日期：2022-01-30 16:03:31
 *  作者：xujunze
 *  输入参数：无
 *  输出参数：无
 *  返回值：无
******************************************************************/
struct data
{
	char  a;
	int   b;
	short c;
};

void test03()
{
	struct data s;
	printf("size : %d\n", sizeof(s));
	printf("a : %p\n", &s.a);
	printf("b : %p\n", &s.b);
	printf("c : %p\n", &s.c);
	printf("---------------------------\n");
}

// 1. 结构体起始地址：第一个成员应该放在起始地址可以被最大的成员大小长度整除的地方
// 2. 结构体中每个成员相对于起始地址的偏移量：成员应该放在地址为min（当前成员的大小，
// #pargama pack(n)）整数倍的地方开始（比如int在32位机器为４字节，#pargama pack(2)，那么从2的倍数地方开始存储）。
// 3. 结构体总大小：sizeof的结果，必须是min（结构体内部最大成员，#pargama pack(n)）的整数倍，不足要补齐。
// 4. 结构体做为成员的对齐规则。如果一个结构体B里嵌套另一个结构体A，还是以最大成员类型的大小对齐，
// 但是结构体A的起点为A内部最大成员的整数倍的地方。（struct B里存有struct A，
// A里有char，int，double等成员，那A应该从8的整数倍开始存储。）结构体A中的成员的对齐规则仍满足原则1、原则2。

/****************************************************************
 *  函数名称：结构体内存对齐例2
 *  创建日期：2022-01-30 16:36:42
 *  作者：xujunze
 *  输入参数：无
 *  输出参数：无
 *  返回值：无
******************************************************************/

#pragma pack(show)
//value of #pragma pack(show) == 8
//#pragma pack(1) //对齐模数是可以改的，修改为2 ^ n

//第一个属性开始，从0开始偏移
//第二个属性 是放在 该类型的大小  与  对齐模数比 取小的值 的整数倍
//将所有属性都计算完之后，再整体做二次偏移，将整体计算的结果，要放在结构体最大类型 与对齐模数比
//取小的值的 整数倍上，如下 20不是 最大类型double大小8 与对齐模数比的整数倍上，最接近的是24，所以是24
typedef struct _STUDENT
{
	int a;   //0 ~ 3
	char b;   //4
	double c;  //8 ~ 15  double放到8的整数倍上
	float d;	//16 ~ 20  float放到4的整数倍上
} Student;

typedef struct _STUDENT2
{
	char a;
	Student b;
	double c;
} Student2;

void test04()
{
	//Student
	//a从偏移量0位置开始存储
	//b从4位置开始存储
	//c从8位置开始存储
	//d从12位置开存储
	//所以Student内部对齐之后的大小为20 ，整体对齐，整体为最大类型的整数倍 也就是8的整数倍 为24

	printf("sizeof Student:%d\n",sizeof(Student));

	//Student2 
	//a从偏移量为0位置开始 
	//b从偏移量为Student内部最大成员整数倍开始，也就是8开始
	//c从8的整数倍地方开始,也就是32开始
	//所以结构体Sutdnet2内部对齐之后的大小为：40 ， 由于结构体中最大成员为8，必须为8的整数倍 所以大小为40
	printf("sizeof Student2:%d\n",sizeof(Student2));
	printf("---------------------------\n");
}

int main(void)
{
	test01();
	//test02();
	test03();
	//test04();
}